#include<stdio.h>
#include"dtype.h"
#include"conv_0_weight.h"
#include"conv_0_bias.h"
#include"conv_2_weight.h"
#include"conv_2_bias.h"
#include"classifier_0_weight.h"
#include"classifier_0_bias.h"
#include"Conv0_and_relu.h"
#include"Conv2_and_relu.h"
#include"Maxpool.h"
#include"Forward.h"



int main(){
    Num_types raw_data[3][150] = {
        {0.4000,  0.4000,  0.4000,  0.5000,  0.6000,  0.6000,  0.7000,  0.8000,
         0.9000,  1.0000,  1.2000,  1.2000,  1.3000,  1.3000,  1.2000,  1.2000,
         1.2000,  1.2000,  1.2000,  1.3000,  1.3000,  1.3000,  1.2000,  1.2000,
         1.0000,  0.9000,  0.7000,  0.6000,  0.5000,  0.4000,  0.4000,  0.3000,
         0.3000,  0.3000,  0.2000,  0.1000, -0.1000, -0.3000, -0.6000, -0.8000,
        -0.9000, -1.1000, -1.2000, -1.2000, -1.3000, -1.3000, -1.4000, -1.4000,
        -1.4000, -1.5000, -1.4000, -1.4000, -1.4000, -1.4000, -1.3000, -1.2000,
        -1.0000, -0.8000, -0.7000, -0.5000, -0.3000, -0.0000,  0.3000,  0.5000,
         0.6000,  0.7000,  0.7000,  0.7000,  0.6000,  0.6000,  0.6000,  0.6000,
         0.6000,  0.6000,  0.6000,  0.6000,  0.5000,  0.5000,  0.4000,  0.3000,
         0.1000, -0.1000, -0.3000, -0.4000, -0.5000, -0.6000, -0.7000, -0.8000,
        -0.8000, -0.9000, -1.0000, -1.1000, -1.3000, -1.4000, -1.5000, -1.6000,
        -1.6000, -1.5000, -1.4000, -1.3000, -1.2000, -0.9000, -0.7000, -0.5000,
        -0.4000, -0.4000, -0.3000, -0.3000, -0.3000, -0.2000, -0.1000, -0.1000,
        -0.1000, -0.1000, -0.0000, -0.0000, -0.0000, -0.1000, -0.1000, -0.0000,
        -0.0000, -0.0000, -0.1000, -0.1000, -0.1000, -0.1000, -0.1000, -0.1000,
        -0.1000, -0.1000, -0.1000, -0.0000, -0.0000, -0.0000, -0.0000, -0.0000,
        -0.0000, -0.0000, -0.1000, -0.1000, -0.1000, -0.1000, -0.1000, -0.1000,
        -0.0000, -0.0000, -0.0000, -0.0000, -0.0000, -0.0000},
          {-0.1000, -0.1000, -0.2000, -0.2000, -0.3000, -0.3000, -0.3000, -0.4000,
        -0.4000, -0.5000, -0.5000, -0.5000, -0.3000, -0.2000, -0.1000,  0.1000,
         0.2000,  0.2000,  0.2000,  0.1000, -0.1000, -0.2000, -0.3000, -0.3000,
        -0.2000, -0.0000,  0.1000,  0.3000,  0.3000,  0.3000,  0.2000,  0.0000,
        -0.2000, -0.4000, -0.5000, -0.5000, -0.5000, -0.3000, -0.2000, -0.1000,
        -0.1000, -0.1000, -0.2000, -0.2000, -0.3000, -0.4000, -0.5000, -0.7000,
        -0.8000, -1.0000, -1.0000, -1.1000, -1.0000, -0.9000, -0.7000, -0.5000,
        -0.3000, -0.2000, -0.1000,  0.1000,  0.1000, -0.0000, -0.1000, -0.2000,
        -0.2000, -0.2000, -0.1000,  0.0000,  0.1000,  0.2000,  0.2000,  0.2000,
         0.2000,  0.2000,  0.1000,  0.0000, -0.0000, -0.0000, -0.1000, -0.1000,
        -0.1000, -0.1000,  0.0000,  0.1000,  0.1000,  0.1000,  0.1000,  0.1000,
         0.0000,  0.0000,  0.0000, -0.0000, -0.0000, -0.0000, -0.0000,  0.0000,
         0.0000,  0.0000, -0.1000, -0.1000, -0.2000, -0.2000, -0.2000, -0.1000,
         0.0000,  0.1000,  0.2000,  0.2000,  0.3000,  0.2000,  0.2000,  0.1000,
         0.1000,  0.1000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,
         0.1000,  0.1000,  0.1000,  0.1000,  0.1000,  0.1000,  0.1000,  0.1000,
         0.1000,  0.1000,  0.1000,  0.1000,  0.1000,  0.1000,  0.1000,  0.1000,
         0.1000,  0.1000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,
         0.0000,  0.0000,  0.0000,  0.0000,  0.0000, -0.0000},
          {0.1000,  0.0000,  0.0000,  0.0000,  0.1000,  0.1000,  0.1000,  0.1000,
         0.1000,  0.1000,  0.1000,  0.1000, -0.0000, -0.0000,  0.0000, -0.1000,
        -0.2000, -0.3000, -0.4000, -0.5000, -0.5000, -0.6000, -0.6000, -0.7000,
        -0.7000, -0.8000, -0.8000, -0.9000, -1.0000, -1.0000, -1.1000, -1.1000,
        -1.1000, -1.2000, -1.2000, -1.3000, -1.3000, -1.4000, -1.5000, -1.5000,
        -1.5000, -1.5000, -1.5000, -1.5000, -1.5000, -1.4000, -1.3000, -1.2000,
        -1.0000, -0.9000, -0.7000, -0.4000, -0.1000,  0.2000,  0.6000,  0.9000,
         1.2000,  1.5000,  1.7000,  1.8000,  1.9000,  1.9000,  1.9000,  1.9000,
         1.9000,  1.9000,  1.8000,  1.7000,  1.7000,  1.5000,  1.4000,  1.3000,
         1.3000,  1.1000,  1.0000,  0.8000,  0.7000,  0.5000,  0.4000,  0.3000,
         0.2000,  0.1000,  0.0000, -0.1000, -0.2000, -0.3000, -0.4000, -0.5000,
        -0.6000, -0.6000, -0.7000, -0.8000, -0.9000, -1.0000, -1.1000, -1.1000,
        -1.1000, -1.1000, -1.0000, -0.9000, -0.8000, -0.7000, -0.7000, -0.6000,
        -0.5000, -0.4000, -0.4000, -0.3000, -0.3000, -0.2000, -0.2000, -0.2000,
        -0.2000, -0.2000, -0.2000, -0.2000, -0.1000, -0.1000, -0.1000, -0.1000,
        -0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000, -0.0000, -0.0000,
        -0.0000, -0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.1000,
         0.1000,  0.1000,  0.1000,  0.1000,  0.1000,  0.1000,  0.1000,  0.1000,
         0.1000,  0.1000,  0.1000,  0.1000,  0.0000,  0.0000},
          };
    

    //raw_data与conv_0_weight卷积
    //恰好卷积核与raw_data都是三列，不用左右移动了，函数里少个for循环
    //通过第一层卷积后数据为30*50，存到这个数组里
    Num_types raw_data2[30][50] = {{0}};
    Conv0(raw_data,conv_0_weight,conv_0_bias,3,raw_data2);

    ////输出,测试通过,完全没问题
    // for (int i = 0; i < 30; i++)
    // {
    //     printf("Output for data %d:\n", i);
    //     for (int j = 0; j < 50; j++)
    //     {
    //         printf("%f,",raw_data2[i][j]);
    //     }
    //     printf("\n");
    // }
    

    // raw_data2,再次进行卷积和relu激活函数
    // 通过第二层卷积核relu的结果存到这个数组里
    Num_types raw_data3[15][16] = {{0}};
    Conv2(raw_data2, conv_2_weight ,conv_2_bias ,3 , raw_data3);
    
    //输出
    for (int i = 0; i < 15; i++)
    {
        printf("Output for data %d:\n", i);
        for (int j = 0; j < 16; j++)
        {
            printf("%f,",raw_data3[i][j]);
        }
        printf("\n");
    }

    // 池化层
    Num_types raw_data4[15][5] = {{0}};
    Maxpool(raw_data3,3,3,raw_data4);

    // for (int i = 0; i < 15; i++)
    // {
    //     printf("Output for data %d:\n", i);
    //     for (int j = 0; j < 5; j++)
    //     {
    //         printf("%f,",raw_data4[i][j]);
    //     }
    //     printf("\n");
    // }

    //将数据拉成一维，这个比较简单，不单独写个头文件了
    Num_types raw_data5[75] = {0};
    for (int i = 0; i < 15; i++)
    {
        for (int j = 0; j < 5; j++)
        {
            raw_data5[i*5+j] = raw_data4[i][j];
        }   
    }

    //接MLP,前向传播
    Num_types raw_data6[13] = {0};
    Forward(raw_data5, classifier_0_weight, classifier_0_bias, raw_data6);

    //输出raw_data6
    for (int i = 0; i < 13; i++)
    {
        printf("%f,", raw_data6[i]);
    }

    //找到最大值的index
    char motion_names[13][10] = {{"RightAngle"}, {"SharpAngle"}, {"Lightning"}, 
                                {"Triangle"}, {"Letter_h"}, {"letter_R"}, 
                                {"letter_W"}, {"letter_phi"}, {"Circle"}, 
                                {"UpAndDown"}, {"Horn"}, {"Wave"}, {"NoMotion"}};

    int maxIndex = 0; // 假设第一个元素为最大值
    for (int i = 1; i < 13; i++) {
        if (raw_data6[i] > raw_data6[maxIndex]) {
            maxIndex = i; // 更新最大值的索引
        }
    }
    
    
    printf("%s\n", motion_names[maxIndex]);

    return 0;
}
